{
  "javascript": [
  {
    "title": "Event Loop",
    "content": "<h2>What is the Event Loop?</h2><p><b>The Event Loop</b> is a mechanism in JavaScript that continuously checks for tasks to execute, processes them one by one, and ensures that <i>asynchronous callbacks</i> run after the current code finishes.</p><h2>What is the Call Stack?</h2><p>The <b>Call Stack</b> is a data structure that keeps track of the functions currently being executed. When a function is called, it’s added (<i>pushed</i>) to the stack, and when it finishes, it’s removed (<i>popped</i>).</p><h2>What are Macrotasks?</h2><p><b>Macrotasks</b> (or just “tasks”) are units of work that get queued in the task queue and run one by one after the current call stack is empty. Examples include:</p><ul><li><code>setTimeout</code> callbacks</li><li><code>setInterval</code> callbacks</li><li>User interactions (<i>clicks, input events</i>)</li><li>Network events (like <code>XHR</code> or <code>fetch</code> responses)</li></ul><h2>What are Microtasks?</h2><p><b>Microtasks</b> are smaller units of work that run immediately after the current task completes, before the next macrotask starts. They have higher priority. Examples include:</p><ul><li><code>Promise.then()</code>, <code>Promise.catch()</code>, <code>Promise.finally()</code> callbacks</li><li><code>queueMicrotask()</code> calls</li><li><code>MutationObserver</code> callbacks</li></ul>",
    "code": "console.log('script start');\n\nPromise.resolve().then(() => {\n  console.log('promise callback start');\n\n  setTimeout(() => {\n    console.log('setTimeout inside promise');\n\n    Promise.resolve().then(() => {\n      console.log('promise inside setTimeout');\n    });\n\n  }, 0);\n\n  console.log('promise callback end');\n});\n\nsetTimeout(() => {\n  console.log('first setTimeout start');\n\n  Promise.resolve().then(() => {\n    console.log('promise inside first setTimeout');\n  });\n\n}, 0);\n\nconsole.log('script end');"
  },
  {
    "title": "Lexical Scope & Closures",
    "content": "<p><b>Lexical scope</b> means the scope of a variable or any declaration is determined by where it is defined in the source code, not by where it is accessed. <b>A closure</b> is a function that remembers the variables from its outer scope even after that scope has exited. Lexical scope is static, while closures are <i>runtime constructs</i> that allow nested functions to retain access to variables from their lexical scope.</p>",
    "examples": [
      {
        "code": "function outer() {\n  var a = 10;\n  function inner() {\n    console.log(a);\n  }\n  inner();\n}\nouter();",
        "description": "Here, <code>inner</code> can access <code>a</code> because it is defined within the lexical scope of <code>outer</code>. Lexical scope allows inner functions to see variables from the outer function where they were defined.",
        "whyItHappens": "The inner function is physically written inside <code>outer</code>, so it can access variables from that scope. <i>Lexical scoping</i> is determined at code definition time."
      },
      {
        "code": "function outer(){\n  let count = 0;\n  return function inner(){ count++; return count; }\n}\nconst inc = outer();\nconsole.log(inc()); // 1\nconsole.log(inc()); // 2",
        "description": "The inner function forms a <b>closure</b> over <code>count</code>. Even though <code>outer</code> has finished executing, <code>inner</code> retains access to <code>count</code>, so each call increments the same variable.",
        "whyItHappens": "Closures keep a reference to the variables of their lexical scope, allowing them to persist beyond the lifetime of the outer function."
      },
      {
        "code": "function createFunctions() {\n  let funcs = [];\n  for (var i = 0; i < 3; i++) {\n    funcs.push(function() { console.log(i); });\n  }\n  return funcs;\n}\nconst functions = createFunctions();\nfunctions[0](); // 3\nfunctions[1](); // 3\nfunctions[2](); // 3",
        "description": "Using <code>var</code> creates a function-scoped variable <code>i</code>. All functions in the array share the same <code>i</code>, which ends at 3 after the loop. So all functions print 3.",
        "whyItHappens": "<code>var</code> is function-scoped, so the same <code>i</code> is shared across all iterations. Closures capture the variable reference, not its value at the time of creation."
      },
      {
        "code": "function createFunctions() {\n  let funcs = [];\n  for (let i = 0; i < 3; i++) {\n    funcs.push(function() { console.log(i); });\n  }\n  return funcs;\n}\nconst functions = createFunctions();\nfunctions[0](); // 0\nfunctions[1](); // 1\nfunctions[2](); // 2",
        "description": "<code>let</code> creates a block-scoped variable <code>i</code>. Each iteration has its own <code>i</code>, so each function captures the correct value in a closure.",
        "whyItHappens": "Block-scoped <code>let</code> ensures a new <code>i</code> is created for each loop iteration. Each closure remembers its specific <code>i</code> value."
      },
      {
        "code": "function createFunctions() {\n  let funcs = [];\n  for (var i = 0; i < 3; i++) {\n    (function(index) {\n      funcs.push(function() { console.log(index); });\n    })(i);\n  }\n  return funcs;\n}\nconst functions = createFunctions();\nfunctions[0](); // 0\nfunctions[1](); // 1\nfunctions[2](); // 2",
        "description": "An <b>IIFE</b> captures the current value of <code>i</code> as <code>index</code> for each function. This creates a closure over <code>index</code>, allowing each function to log the correct value.",
        "whyItHappens": "The IIFE executes immediately with the current <code>i</code> value, so each closure retains its own copy of <code>index</code> instead of sharing the same variable."
      },
      {
        "code": "function counter() {\n  let count = 0;\n  return {\n    increment: function() { count++; },\n    getCount: function() { return count; }\n  };\n}\nconst c = counter();\nc.increment();\nc.increment();\nconsole.log(c.getCount()); // 2",
        "description": "The returned object methods form closures over <code>count</code>. The <code>increment</code> method can modify <code>count</code>, and <code>getCount</code> can read it. The variable persists across multiple method calls.",
        "whyItHappens": "Closures maintain access to the outer variable <code>count</code>, allowing it to be shared and modified across multiple function calls even after the outer function has finished."
      },
      {
        "code": "var a = 10;\n\nfunction outer() {\n  console.log(a);\n\n  var a = 20;\n\n  function inner() {\n    console.log(a);\n\n    var a = 30;\n    console.log(this.a);\n\n    (function () {\n      console.log(a);\n      console.log(this.a);\n    })();\n  }\n\n  inner();\n}\n\nouter();",
        "description": "This example demonstrates <b>variable hoisting</b>, shadowing, and how <code>this</code> behaves differently from lexical variables. Variables declared with <code>var</code> are hoisted and may shadow outer variables. Inside the inner function and IIFE, <code>this.a</code> refers to the global object (or undefined in strict mode).",
        "whyItHappens": "Hoisting moves <code>var</code> declarations to the top of their scope. Lexical variables are accessible according to their declaration, while <code>this</code> is determined by the function call context, not the lexical scope."
      }
    ]
  }
]
,
  "typescript": [
    {
      "title": "Generics",
      "content": "Generics allow you to create reusable components that work with different types without losing type safety.",
      "code": "function identity<T>(value: T): T { return value; }\nconsole.log(identity<string>('Hello'));"
    }
  ],
  "htmlcss": [
    {
      "title": "Flexbox Basics",
      "content": "Flexbox is a layout mode that arranges elements in a row or column, distributing space evenly.",
      "code": ".container { display: flex; justify-content: space-between; align-items: center; }"
    }
  ],
  "react": [
    {
      "title": "useState Hook",
      "content": "useState lets you add state to functional components in React.",
      "code": "import { useState } from 'react';\n\nfunction Counter(){\n  const [count, setCount] = useState(0);\n  return <button onClick={()=>setCount(count+1)}>{count}</button>;\n}"
    }
  ]
}