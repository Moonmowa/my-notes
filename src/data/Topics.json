{
  "javascript": [
    {
      "title": "Declaring variables: var, let, const & Temporal Dead Zone",
      "content": "<p>In JavaScript, variables can be declared using <b>var</b>, <b>let</b>, and <b>const</b>. Each has its own scope, hoisting behavior, and usage rules:</p><ul><li><b>var</b>: Function-scoped. It is <b>hoisted</b> and initialized with <code>undefined</code>. Accessing it before declaration does not throw an error but returns <code>undefined</code>. <b>Example:</b> <code>console.log(a); var a = 10; // undefined</code></li><li><b>let</b>: Block-scoped. Resides in the <b>Temporal Dead Zone (TDZ)</b> from the start of its block until the declaration is evaluated. Accessing it before declaration throws a <b>ReferenceError</b>. <b>Example:</b> <code>console.log(b); let b = 20; // ReferenceError</code></li><li><b>const</b>: Block-scoped and also resides in the <b>TDZ</b>. Must be initialized at declaration and cannot be reassigned. <b>Example:</b> <code>const c = 30; c = 40; // TypeError</code></li></ul><p><b>Temporal Dead Zone (TDZ)</b>: The phase between entering a scope and the actual declaration of <b>let</b> or <b>const</b>. During this phase, the variables exist but cannot be accessed. TDZ helps prevent accidental access to uninitialized variables, improving code safety.</p><p><b>Summary:</b></p><ul><li><b>var</b>: function-scoped, hoisted, initialized with <code>undefined</code></li><li><b>let</b>: block-scoped, hoisted, uninitialized in TDZ</li><li><b>const</b>: block-scoped, hoisted, uninitialized in TDZ, must be assigned at declaration, cannot be reassigned</li></ul>",
      "examples": [
        {
          "code": "console.log(a);\nvar a = 10;",
          "description": "Variable declared with 'var' is hoisted; outputs undefined.",
          "whyItHappens": "'var' declarations are hoisted with default value undefined, so accessing before assignment doesn't throw an error."
        },
        {
          "code": "console.log(b);\nlet b = 20;",
          "description": "Variable declared with 'let' is in Temporal Dead Zone; throws ReferenceError.",
          "whyItHappens": "'let' is block-scoped and not initialized until the line is executed, creating a TDZ."
        },
        {
          "code": "const c = 30;\nc = 40;",
          "description": "Cannot reassign a 'const' variable; throws TypeError.",
          "whyItHappens": "'const' must be initialized and cannot be reassigned after declaration."
        }
      ]
    },
    {
      "title": "Equality operators (== vs ===)",
      "content": "'==' is the abstract equality operator, which compares values after type coercion. '===' is the strict equality operator, which compares both value and type without coercion. Using '===' avoids unexpected type conversions and is generally recommended.",
      "examples": [
        {
          "code": "5 == '5';",
          "description": "Abstract equality allows type coercion; returns true.",
          "whyItHappens": "JavaScript converts the string '5' to number 5 before comparison."
        },
        {
          "code": "5 === '5';",
          "description": "Strict equality compares value and type; returns false.",
          "whyItHappens": "Number and string types are different; no coercion happens."
        },
        {
          "code": "null == undefined;\nnull === undefined;",
          "description": "Abstract equality: true, Strict equality: false",
          "whyItHappens": "'==' considers null and undefined equal, but '===' checks type as well."
        }
      ]
    },
    {
      "title": "Spread (...) and rest parameters",
      "content": "The spread operator '...' expands iterable elements like arrays or objects into individual elements. Rest parameters '...' collect multiple arguments into an array. Spread is used in function calls, array/object copying, or merging. Rest is used in function definitions to handle variable numbers of arguments.",
      "examples": [
        {
          "code": "const arr = [1,2,3];\nconst newArr = [...arr, 4, 5];",
          "description": "Spread operator expands array elements into new array.",
          "whyItHappens": "'...' spreads the elements individually; newArr becomes [1,2,3,4,5]."
        },
        {
          "code": "function sum(...nums) { return nums.reduce((a,b) => a+b, 0); }\nsum(1,2,3,4);",
          "description": "Rest parameter collects all arguments into array 'nums'.",
          "whyItHappens": "'...nums' gathers any number of arguments passed to the function."
        },
        {
          "code": "const obj1 = {a:1, b:2};\nconst obj2 = {...obj1, c:3};",
          "description": "Spread operator copies properties into new object.",
          "whyItHappens": "'...' expands key-value pairs from obj1 into obj2."
        }
      ]
    },
    {
      "title": "Destructuring (array & object)",
      "content": "Destructuring allows extracting values from arrays or objects into distinct variables in a concise syntax. Array destructuring uses position, while object destructuring uses property names. Default values can be provided during destructuring.",
      "examples": [
        {
          "code": "const arr = [1,2,3];\nconst [x, y] = arr;",
          "description": "Array destructuring assigns 1 to x and 2 to y.",
          "whyItHappens": "Positions in array match the variable order in destructuring."
        },
        {
          "code": "const obj = {a:10, b:20};\nconst {a, b} = obj;",
          "description": "Object destructuring assigns properties 'a' and 'b' to variables.",
          "whyItHappens": "Variable names match object property names for assignment."
        },
        {
          "code": "const {a, c=30} = obj;",
          "description": "Default value 30 assigned to c since 'c' property does not exist in obj.",
          "whyItHappens": "Provides fallback when property is undefined."
        }
      ]
    },
    {
      "title": "Event Loop",
      "content": "<h2>What is the Event Loop?</h2><p><b>The Event Loop</b> is a mechanism in JavaScript that continuously checks for tasks to execute, processes them one by one, and ensures that <i>asynchronous callbacks</i> run after the current code finishes.</p><h2>What is the Call Stack?</h2><p>The <b>Call Stack</b> is a data structure that keeps track of the functions currently being executed. When a function is called, it’s added (<i>pushed</i>) to the stack, and when it finishes, it’s removed (<i>popped</i>).</p><h2>What are Macrotasks?</h2><p><b>Macrotasks</b> (or just “tasks”) are units of work that get queued in the task queue and run one by one after the current call stack is empty. Examples include:</p><ul><li><code>setTimeout</code> callbacks</li><li><code>setInterval</code> callbacks</li><li>User interactions (<i>clicks, input events</i>)</li><li>Network events (like <code>XHR</code> or <code>fetch</code> responses)</li></ul><h2>What are Microtasks?</h2><p><b>Microtasks</b> are smaller units of work that run immediately after the current task completes, before the next macrotask starts. They have higher priority. Examples include:</p><ul><li><code>Promise.then()</code>, <code>Promise.catch()</code>, <code>Promise.finally()</code> callbacks</li><li><code>queueMicrotask()</code> calls</li><li><code>MutationObserver</code> callbacks</li></ul>",
      "code": "console.log('script start');\n\nPromise.resolve().then(() => {\n  console.log('promise callback start');\n\n  setTimeout(() => {\n    console.log('setTimeout inside promise');\n\n    Promise.resolve().then(() => {\n      console.log('promise inside setTimeout');\n    });\n\n  }, 0);\n\n  console.log('promise callback end');\n});\n\nsetTimeout(() => {\n  console.log('first setTimeout start');\n\n  Promise.resolve().then(() => {\n    console.log('promise inside first setTimeout');\n  });\n\n}, 0);\n\nconsole.log('script end');"
    },
    {
      "title": "Lexical Scope & Closures",
      "content": "<p><b>Lexical scope</b> means the scope of a variable or any declaration is determined by where it is defined in the source code, not by where it is accessed. <b>A closure</b> is a function that remembers the variables from its outer scope even after that scope has exited. Lexical scope is static, while closures are <i>runtime constructs</i> that allow nested functions to retain access to variables from their lexical scope.</p>",
      "examples": [
        {
          "code": "function outer() {\n  var a = 10;\n  function inner() {\n    console.log(a);\n  }\n  inner();\n}\nouter();",
          "description": "Here, <code>inner</code> can access <code>a</code> because it is defined within the lexical scope of <code>outer</code>. Lexical scope allows inner functions to see variables from the outer function where they were defined.",
          "whyItHappens": "The inner function is physically written inside <code>outer</code>, so it can access variables from that scope. <i>Lexical scoping</i> is determined at code definition time."
        },
        {
          "code": "function outer(){\n  let count = 0;\n  return function inner(){ count++; return count; }\n}\nconst inc = outer();\nconsole.log(inc()); // 1\nconsole.log(inc()); // 2",
          "description": "The inner function forms a <b>closure</b> over <code>count</code>. Even though <code>outer</code> has finished executing, <code>inner</code> retains access to <code>count</code>, so each call increments the same variable.",
          "whyItHappens": "Closures keep a reference to the variables of their lexical scope, allowing them to persist beyond the lifetime of the outer function."
        },
        {
          "code": "function createFunctions() {\n  let funcs = [];\n  for (var i = 0; i < 3; i++) {\n    funcs.push(function() { console.log(i); });\n  }\n  return funcs;\n}\nconst functions = createFunctions();\nfunctions[0](); // 3\nfunctions[1](); // 3\nfunctions[2](); // 3",
          "description": "Using <code>var</code> creates a function-scoped variable <code>i</code>. All functions in the array share the same <code>i</code>, which ends at 3 after the loop. So all functions print 3.",
          "whyItHappens": "<code>var</code> is function-scoped, so the same <code>i</code> is shared across all iterations. Closures capture the variable reference, not its value at the time of creation."
        },
        {
          "code": "function createFunctions() {\n  let funcs = [];\n  for (let i = 0; i < 3; i++) {\n    funcs.push(function() { console.log(i); });\n  }\n  return funcs;\n}\nconst functions = createFunctions();\nfunctions[0](); // 0\nfunctions[1](); // 1\nfunctions[2](); // 2",
          "description": "<code>let</code> creates a block-scoped variable <code>i</code>. Each iteration has its own <code>i</code>, so each function captures the correct value in a closure.",
          "whyItHappens": "Block-scoped <code>let</code> ensures a new <code>i</code> is created for each loop iteration. Each closure remembers its specific <code>i</code> value."
        },
        {
          "code": "function createFunctions() {\n  let funcs = [];\n  for (var i = 0; i < 3; i++) {\n    (function(index) {\n      funcs.push(function() { console.log(index); });\n    })(i);\n  }\n  return funcs;\n}\nconst functions = createFunctions();\nfunctions[0](); // 0\nfunctions[1](); // 1\nfunctions[2](); // 2",
          "description": "An <b>IIFE</b> captures the current value of <code>i</code> as <code>index</code> for each function. This creates a closure over <code>index</code>, allowing each function to log the correct value.",
          "whyItHappens": "The IIFE executes immediately with the current <code>i</code> value, so each closure retains its own copy of <code>index</code> instead of sharing the same variable."
        },
        {
          "code": "function counter() {\n  let count = 0;\n  return {\n    increment: function() { count++; },\n    getCount: function() { return count; }\n  };\n}\nconst c = counter();\nc.increment();\nc.increment();\nconsole.log(c.getCount()); // 2",
          "description": "The returned object methods form closures over <code>count</code>. The <code>increment</code> method can modify <code>count</code>, and <code>getCount</code> can read it. The variable persists across multiple method calls.",
          "whyItHappens": "Closures maintain access to the outer variable <code>count</code>, allowing it to be shared and modified across multiple function calls even after the outer function has finished."
        },
        {
          "code": "var a = 10;\n\nfunction outer() {\n  console.log(a);\n\n  var a = 20;\n\n  function inner() {\n    console.log(a);\n\n    var a = 30;\n    console.log(this.a);\n\n    (function () {\n      console.log(a);\n      console.log(this.a);\n    })();\n  }\n\n  inner();\n}\n\nouter();",
          "description": "This example demonstrates <b>variable hoisting</b>, shadowing, and how <code>this</code> behaves differently from lexical variables. Variables declared with <code>var</code> are hoisted and may shadow outer variables. Inside the inner function and IIFE, <code>this.a</code> refers to the global object (or undefined in strict mode).",
          "whyItHappens": "Hoisting moves <code>var</code> declarations to the top of their scope. Lexical variables are accessible according to their declaration, while <code>this</code> is determined by the function call context, not the lexical scope."
        }
      ]
    },
    {
      "title": "Execution Context",
      "content": "<p><b>Execution Context</b> is the environment in which JavaScript code runs.</p><p><b>👉 Types:</b></p><ul style='margin-left:20px; color:#2b6cb0;'><li><b>Global Execution Context (GEC):</b> Created once at program start, holds global objects (<code>window</code> / <code>global</code>) and <code>this</code>.</li><li><b>Function Execution Context (FEC):</b> Created whenever a function is invoked, each call gets its own context.</li><li><b>Eval Execution Context:</b> Rare, discouraged.</li></ul><p><b>👉 Phases:</b></p><ul style='margin-left:20px; color:#38a169;'><li><b>Creation Phase:</b> Creates variable environment (hoists <code>var</code>, function declarations), creates lexical environment (scopes for <code>let</code>/<code>const</code>), sets up <code>this</code>.</li><li><b>Execution Phase:</b> Assigns values and executes code line by line.</li></ul>",
      "examples": [
        {
          "code": "console.log(a); // undefined\nvar a = 5;\n\nconsole.log(b); // ReferenceError\nlet b = 10;",
          "description": "Demonstrates how <code>var</code> is hoisted and initialized as <code>undefined</code>, while <code>let</code> is hoisted but stays in the <b>Temporal Dead Zone</b> until initialized.",
          "whyItHappens": "In the <b>creation phase</b>, variables declared with <code>var</code> are set to <code>undefined</code>. <code>let</code> and <code>const</code> are hoisted too but left uninitialized, so accessing them before their declaration causes a ReferenceError."
        },
        {
          "code": "function foo() {\n  console.log(a);\n  var a = 10;\n  console.log(b);\n  let b = 20;\n}\nfoo();",
          "description": "Within a function execution context, <code>var</code> is hoisted to the top of its scope as <code>undefined</code>, while <code>let</code> stays in the Temporal Dead Zone.",
          "whyItHappens": "During creation, the function context hoists <code>a</code> (var) and <code>b</code> (let). But <code>a</code> is initialized to <code>undefined</code>, while <code>b</code> remains in TDZ until its line executes."
        },
        {
          "code": "var x = 1;\nfunction outer() {\n  console.log(x);\n  var x = 2;\n  function inner() {\n    console.log(x);\n  }\n  inner();\n}\nouter();",
          "description": "Looks like <code>console.log(x)</code> should print 1, but it actually prints <code>undefined</code>. Inner prints 2.",
          "whyItHappens": "Inside <code>outer</code>, <code>var x</code> is hoisted to the top of the function, shadowing the global <code>x</code>. So the first log is <code>undefined</code> (before assignment). Inner inherits that <code>x</code> from its lexical scope, so it prints 2."
        },
        {
          "code": "var a = 100;\nfunction test() {\n  console.log(a);\n  var a = 200;\n  console.log(this.a);\n}\ntest();",
          "description": "Prints <code>undefined</code> then <code>100</code>.",
          "whyItHappens": "<code>a</code> inside <code>test</code> is hoisted, so the first log sees it as <code>undefined</code>. <code>this.a</code> refers to the global object’s <code>a</code> (100 in non-strict mode). This shows the difference between variable environment and <code>this</code> binding."
        },
        {
          "code": "var a = 10;\n(function() {\n  console.log(a);\n  var a = 20;\n  console.log(a);\n})();",
          "description": "Prints <code>undefined</code> then <code>20</code>.",
          "whyItHappens": "Within the IIFE execution context, <code>a</code> is hoisted and initialized as <code>undefined</code>, shadowing the outer <code>a</code>. After assignment, <code>a</code> becomes 20."
        },
        {
          "code": "function tricky() {\n  console.log(a);\n  console.log(b);\n  var a = 1;\n  let b = 2;\n}\ntry {\n  tricky();\n} catch (e) {\n  console.log('Error:', e.message);\n}",
          "description": "Logs <code>undefined</code> for <code>a</code>, then throws a <code>ReferenceError</code> for <code>b</code>.",
          "whyItHappens": "Hoisting puts <code>a</code> into memory as <code>undefined</code>, but <code>b</code> is hoisted into TDZ. Attempting to access it before declaration triggers a ReferenceError."
        },
        {
          "code": "var a = 10;\nfunction outer() {\n  var a = 20;\n  function inner() {\n    var a = 30;\n    console.log(a);\n    console.log(this.a);\n  }\n  inner();\n}\nouter();",
          "description": "Prints <code>30</code> then <code>10</code>.",
          "whyItHappens": "The innermost <code>a</code> shadows outer ones. <code>this.a</code> points to global <code>a</code> (10) because <code>inner()</code> is called as a plain function (not as a method). This tests understanding of both execution context and <code>this</code>."
        },
        {
          "code": "console.log(foo);\nfunction foo() { return 'declared'; }\nvar foo = 'assigned';",
          "description": "Prints the function definition, not <code>undefined</code> or 'assigned'.",
          "whyItHappens": "Function declarations are hoisted before variables. So during creation, <code>foo</code> is first bound to the function. Later, <code>var foo</code> is hoisted but ignored since it’s already declared. Only after execution, <code>foo</code> becomes 'assigned'."
        }
      ]
    },
    {
      "title": "Objects in JavaScript",
      "content": "<p><b>Objects</b> in JavaScript are collections of key-value pairs. Keys are usually strings (or symbols), and values can be primitives, functions, or other objects. Objects allow us to model real-world entities and encapsulate related data and behavior.</p><p>In JavaScript, almost everything is an object (arrays, functions, dates, regex, etc.), except the 7 primitive types (number, bigint, string, boolean, undefined, null, symbol).</p>",
      "examples": [
        {
          "code": "const person = {\n  name: \"Alice\",\n  age: 25,\n  greet: function() {\n    console.log(\"Hello, I'm \" + this.name);\n  }\n};\n\nperson.greet(); // Hello, I'm Alice",
          "description": "An object literal with properties and a method. Keys are strings and values can be anything.",
          "whyItHappens": "Objects group related data and behavior together, making them the building blocks for complex structures."
        },
        {
          "code": "const obj = { a: 1, b: 2 };",
          "description": "The most common way: <b>Object literal</b> syntax with key-value pairs.",
          "whyItHappens": "Object literals are concise and the preferred way to create simple objects."
        },
        {
          "code": "const obj = new Object();\nobj.a = 1;",
          "description": "Using the <b>new Object()</b> constructor to create an empty object, then adding properties.",
          "whyItHappens": "This is less common and more verbose, but functionally equivalent to object literals."
        },
        {
          "code": "function Person(name) {\n  this.name = name;\n}\n\nconst p1 = new Person(\"Alice\");\nconsole.log(p1.name); // Alice",
          "description": "Using a <b>constructor function</b> to create objects with shared structure.",
          "whyItHappens": "Constructor functions (and later ES6 classes) provide a way to generate multiple similar objects efficiently."
        },
        {
          "code": "const proto = { greet() { console.log(\"Hi!\"); } };\nconst obj = Object.create(proto);\nobj.greet(); // Hi!",
          "description": "Using <b>Object.create()</b> to create a new object with a given prototype.",
          "whyItHappens": "This allows explicit control over an object's prototype, making it a powerful tool for prototype-based inheritance."
        },
        {
          "code": "class Person {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nconst p1 = new Person(\"Alice\");\nconsole.log(p1.name); // Alice",
          "description": "Using ES6 <b>class syntax</b> to create objects.",
          "whyItHappens": "Classes are syntactic sugar over constructor functions + prototypes, making OOP patterns easier to read and use."
        }
      ]
    },
    {
      "title": "Property Access in Objects",
      "content": "<p><b>Property access</b> controls how you read/write values on objects. Use <code>dot</code> for static keys and <code>bracket</code> for dynamic keys, spaces, special chars, or symbols. Optional chaining (<code>?.</code>) and nullish coalescing (<code>??</code>) make nested access safe.</p><ul><li><b>Dot</b>: <code>obj.key</code></li><li><b>Bracket</b>: <code>obj[expr]</code> where <i>expr</i> resolves to the key</li><li><b>Symbols</b>: non-string unique keys</li><li><b>Optional chaining</b>: short-circuits on <code>null</code>/<code>undefined</code></li><li><b>\"in\" vs <code>hasOwn</code></b>: <code>in</code> checks prototype chain; <code>Object.hasOwn()</code> checks only own props</li></ul>",
      "examples": [
        {
          "code": "const user = { name: \"CD\", \"fav color\": \"teal\" };\n// Dot vs bracket\nconsole.log(user.name); // dot for simple identifiers\nconsole.log(user[\"fav color\"]); // bracket for spaces/special chars\n\nconst key = 'name';\nconsole.log(user[key]); // dynamic access",
          "description": "Use dot for simple, bracket for computed/dynamic or special-key access.",
          "whyItHappens": "Dot requires a valid identifier known at author time. Bracket evaluates an expression to a string/symbol key at runtime."
        },
        {
          "code": "const id = Symbol('id');\nconst obj = { [id]: 123, id: 'string key' };\nconsole.log(obj[id]); // 123 (symbol key)\nconsole.log(obj.id); // 'string key' (string key)",
          "description": "Symbols create non-colliding keys you can only access via the same symbol reference.",
          "whyItHappens": "Each Symbol value is unique; property lookups must use the exact symbol to match."
        },
        {
          "code": "const data = { settings: { theme: { name: 'dark' } } };\nconsole.log(data.settings?.theme?.name); // 'dark'\nconsole.log(data.profile?.email ?? 'no email'); // 'no email'",
          "description": "Optional chaining prevents errors on missing links; nullish coalescing provides defaults only for null/undefined.",
          "whyItHappens": "<code>?.</code> stops evaluation and returns undefined if the left side is nullish; <code>??</code> returns the right side only when the left is null or undefined."
        },
        {
          "code": "const base = { kind: 'base' };\nconst child = Object.create(base);\nchild.own = true;\nconsole.log('kind' in child); // true (via prototype)\nconsole.log(Object.hasOwn(child, 'kind')); // false (not own)\nconsole.log(Object.hasOwn(child, 'own')); // true",
          "description": "Differentiate own vs inherited properties when checking for existence.",
          "whyItHappens": "The <code>in</code> operator walks the prototype chain; <code>Object.hasOwn</code> only checks the object's own property bag."
        }
      ]
    },
    {
      "title": "Core Object Methods (keys, values, entries, fromEntries, assign)",
      "content": "<p>These methods help you list, transform, or merge object properties. They operate on <b>own enumerable</b> string-keyed props unless noted.</p><ul><li><code>Object.keys(obj)</code> → string keys</li><li><code>Object.values(obj)</code> → values</li><li><code>Object.entries(obj)</code> → <code>[[key,value],...]</code></li><li><code>Object.fromEntries(iter)</code> → entries → object</li><li><code>Object.assign(target, ...sources)</code> → shallow merge</li><li><code>Object.hasOwn(obj, key)</code> → own-prop check</li></ul><p>For descriptors and non-enumerables, use <code>Object.getOwnPropertyNames</code>, <code>Object.getOwnPropertySymbols</code>, <code>Object.getOwnPropertyDescriptors</code>.</p>",
      "examples": [
        {
          "code": "const user = { name: 'CD', age: 26 };\nconsole.log(Object.keys(user)); // ['name', 'age']\nconsole.log(Object.values(user)); // ['CD', 26]\nfor (const [k,v] of Object.entries(user)) {\n console.log(k, v);\n}",
          "description": "Enumerate keys/values/pairs of own enumerable props.",
          "whyItHappens": "These helpers avoid <code>for...in</code> pitfalls (which iterate inherited props) and return arrays suitable for iteration."
        },
        {
          "code": "// Transform object → entries → map → object\nconst prices = { apple: 100, banana: 80 };\nconst withTax = Object.fromEntries(\n Object.entries(prices).map(([k, v]) => [k, Math.round(v * 1.18)])\n);\nconsole.log(withTax); // { apple: 118, banana: 94 }",
          "description": "Use entries + map + fromEntries to transform objects functionally.",
          "whyItHappens": "Entries provide a list representation you can map/filter, then rebuild with fromEntries."
        },
        {
          "code": "// Shallow merge\nconst a = { x: 1, nested: { n: 1 } };\nconst b = { y: 2, nested: { m: 2 } };\nconst merged = Object.assign({}, a, b);\nconsole.log(merged); // { x:1, nested:{ m:2 }, y:2 }\nconsole.log(merged.nested === b.nested); // true (shallow)",
          "description": "<code>assign</code> merges sources left→right, overwriting keys; nested objects are not deep-cloned.",
          "whyItHappens": "<code>assign</code> copies property <i>values</i>; if a value is an object, the reference is copied (shallow)."
        },
        {
          "code": "const obj = Object.create({ inherited: true });\nobj.own = 1;\nconsole.log(Object.hasOwn(obj, 'own')); // true\nconsole.log(Object.hasOwn(obj, 'inherited')); // false",
          "description": "Use <code>Object.hasOwn</code> instead of <code>obj.hasOwnProperty</code> to avoid shadowing issues.",
          "whyItHappens": "Calling the static <code>Object.hasOwn</code> avoids cases where an object overrides or lacks <code>hasOwnProperty</code>."
        }
      ]
    }
  ],
  "typescript": [
    {
      "title": "Generics",
      "content": "Generics allow you to create reusable components that work with different types without losing type safety.",
      "code": "function identity<T>(value: T): T { return value; }\nconsole.log(identity<string>('Hello'));"
    }
  ],
  "htmlcss": [
    {
      "title": "Flexbox Basics",
      "content": "Flexbox is a layout mode that arranges elements in a row or column, distributing space evenly.",
      "code": ".container { display: flex; justify-content: space-between; align-items: center; }"
    }
  ],
  "react": [
    {
      "title": "useState Hook",
      "content": "<p><b>useState</b> is a React Hook that allows you to add state to function components. It returns a pair: the <b>state variable</b> (to read the value) and a <b>function</b> (to update the value). Unlike <code>useRef</code>, updating state with <code>setState</code> <i>triggers a re-render</i> of the component with the new state value.</p><p>Structure: <code>const [stateVariable, setStateVariable] = useState(initialValue)</code></p>",
      "examples": [
        {
          "code": "import { useState } from \"react\";\n\nfunction Counter() {\n  const [count, setCount] = useState(0); // state variable + updater function\n\n  return (\n    <div>\n      <h2>Count: {count}</h2>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}\n\nexport default Counter;",
          "description": "Here, <code>count</code> is the state variable and <code>setCount</code> is the updater function. Each call to <code>setCount</code> triggers a re-render, showing the updated value on screen.",
          "whyItHappens": "React keeps track of the state between renders using its internal hooks system. When <code>setCount</code> is called, React schedules a re-render with the new state value."
        },
        {
          "code": "import { useState } from \"react\";\n\nfunction Toggle() {\n  const [isOn, setIsOn] = useState(false);\n\n  const toggle = () => setIsOn((prev) => !prev);\n\n  return (\n    <div>\n      <p>The switch is {isOn ? 'ON' : 'OFF'}</p>\n      <button onClick={toggle}>Toggle</button>\n    </div>\n  );\n}\n\nexport default Toggle;",
          "description": "Here, <code>isOn</code> is the state variable and <code>setIsOn</code> is the function to update it. The updater is called with a callback that receives the previous state.",
          "whyItHappens": "React guarantees that the state update function (<code>setIsOn</code>) always uses the latest state. Using a callback form avoids bugs when multiple updates happen quickly."
        }
      ]
    },
    {
      "title": "useRef Hook",
      "content": "<p><b>useRef</b> is a React Hook that provides a way to persist values across re-renders without causing a re-render when the value changes. It returns a mutable object with a single property called <code>.current</code>. This makes it useful for two main cases: <b>accessing DOM elements</b> and <b>storing mutable values</b> that survive across renders (like instance variables in class components).</p>",
      "examples": [
        {
          "code": "import { useRef, useEffect } from \"react\";\n\nfunction InputFocus() {\n  const inputRef = useRef(null);\n\n  useEffect(() => {\n    inputRef.current?.focus(); // Focus the input after mount\n  }, []);\n\n  return <input ref={inputRef} type=\"text\" />;\n}\n\nexport default InputFocus;",
          "description": "Here, <code>useRef</code> is used to access a DOM element safely. The <code>inputRef.current</code> holds a reference to the input element, allowing us to call <code>focus()</code> directly.",
          "whyItHappens": "React assigns the DOM node to <code>ref.current</code> when the element is mounted. Unlike <code>document.getElementById</code>, this approach is component-safe and works in React’s declarative model."
        },
        {
          "code": "import { useState, useRef } from \"react\";\n\nfunction Timer() {\n  const [count, setCount] = useState(0);\n  const intervalRef = useRef(null); // behaves like an instance variable\n\n  const startTimer = () => {\n    if (intervalRef.current) return;\n    intervalRef.current = setInterval(() => {\n      setCount((c) => c + 1);\n    }, 1000);\n  };\n\n  const stopTimer = () => {\n    clearInterval(intervalRef.current);\n    intervalRef.current = null;\n  };\n\n  return (\n    <div>\n      <h2>Count: {count}</h2>\n      <button onClick={startTimer}>Start</button>\n      <button onClick={stopTimer}>Stop</button>\n    </div>\n  );\n}\n\nexport default Timer;",
          "description": "Here, <code>useRef</code> is used to store a mutable value (the interval ID). It persists across re-renders but does not trigger a re-render when updated.",
          "whyItHappens": "The object returned by <code>useRef</code> remains the same across renders. Updating <code>.current</code> does not cause re-renders, making it ideal for values like timers or external references."
        }
      ]
    },
    {
      "title": "useReducer Hook",
      "content": "<p><b>useReducer</b> is a React Hook used for managing complex state logic in a component. It is an alternative to <code>useState</code> and is particularly useful when state involves multiple sub-values or when state updates depend on the previous state. <b>useReducer</b> takes a <code>reducer</code> function and an <code>initialState</code>, returning a pair: the current <code>state</code> and a <code>dispatch</code> function to send actions that describe how to update the state.</p>",
      "examples": [
        {
          "code": "import { useReducer } from \"react\";\n\nconst initialState = { count: 0 };\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'increment':\n      return { count: state.count + 1 };\n    case 'decrement':\n      return { count: state.count - 1 };\n    case 'reset':\n      return { count: 0 };\n    default:\n      return state;\n  }\n}\n\nexport default function Counter() {\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  return (\n    <div>\n      <h2>Count: {state.count}</h2>\n      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>\n      <button onClick={() => dispatch({ type: 'increment' })}>+</button>\n      <button onClick={() => dispatch({ type: 'reset' })}>Reset</button>\n    </div>\n  );\n}",
          "description": "In this example, <code>useReducer</code> manages a simple counter. The <code>dispatch</code> function is used to send actions like 'increment', 'decrement', and 'reset', and the reducer returns the updated state based on the action type.",
          "whyItHappens": "The reducer function is a pure function that determines how state changes in response to dispatched actions. This pattern centralizes state updates and makes complex state transitions predictable and easier to debug."
        },
        {
          "code": "import { useReducer } from \"react\";\n\nconst initialState = {\n  formValues: { name: '', age: '', email: '' }\n};\n\nfunction formReducer(state, action) {\n  switch (action.type) {\n    case 'UPDATE_FIELD':\n      return {\n        ...state,\n        formValues: {\n          ...state.formValues,\n          [action.field]: action.value\n        }\n      };\n    default:\n      return state;\n  }\n}\n\nexport default function Form() {\n  const [state, dispatch] = useReducer(formReducer, initialState);\n\n  return (\n    <form>\n      <input\n        value={state.formValues.name}\n        placeholder=\"Name\"\n        onChange={e => dispatch({ type: 'UPDATE_FIELD', field: 'name', value: e.target.value })}\n      />\n      <input\n        value={state.formValues.age}\n        placeholder=\"Age\"\n        onChange={e => dispatch({ type: 'UPDATE_FIELD', field: 'age', value: e.target.value })}\n      />\n      <input\n        value={state.formValues.email}\n        placeholder=\"Email\"\n        onChange={e => dispatch({ type: 'UPDATE_FIELD', field: 'email', value: e.target.value })}\n      />\n      <pre>{JSON.stringify(state.formValues, null, 2)}</pre>\n    </form>\n  );\n}",
          "description": "Here, <code>useReducer</code> manages a form with multiple fields. The reducer handles an 'UPDATE_FIELD' action to dynamically update any form field while preserving the other fields.",
          "whyItHappens": "Using a reducer for form state centralizes updates and makes it easier to manage multiple related fields. Each dispatched action carries the field name and value, and the reducer merges it with the existing state."
        }
      ]
    }
  ]
}